/**
 * HTTP 请求封装
 * @module utils/request
 */

import type {
	HttpMethod,
	HttpInitOptions,
	HttpRequestOptions,
	ResponseData,
	DataResponse,
	HttpInterceptors
} from './type.uts'

// 导出类型供外部使用
export type {
	HttpMethod,
	HttpInitOptions,
	HttpRequestOptions,
	ResponseData,
	DataResponse,
	HttpInterceptors
}

/**
 * HTTP 请求类
 * @description 封装 uni.request，支持拦截器、自动认证、统一错误处理
 * @example
 * ```ts
 * const http = new HttpRequest({
 *   baseURL: 'https://api.example.com',
 *   showLoading: true,
 *   autoAuth: true
 * })
 *
 * // 设置拦截器
 * http.setInterceptors({
 *   request: (options) => {
 *     // 自定义请求处理
 *     return options
 *   },
 *   response: (res, options) => {
 *     // 自定义响应处理
 *     return res.data
 *   }
 * })
 *
 * // 发起请求
 * const data = await http.get<UserInfo>('/user/info')
 * ```
 */
class HttpRequest {
	private baseURL : string
	private header : UTSJSONObject
	private showLoading : boolean
	private autoAuth : boolean
	private interceptors : HttpInterceptors = {}
	private timeout : number

	constructor(options : HttpInitOptions) {
		this.baseURL = options.baseURL
		this.header = {
			'Content-Type': 'application/json;charset=utf-8'
		} as UTSJSONObject
		if (options.header != null) {
			for (const key in options.header) {
				this.header[key] = options.header[key]
			}
		}
		this.showLoading = options.showLoading ?? true
		this.autoAuth = options.autoAuth ?? true
		this.timeout = options.timeout ?? 50000
	}

	/**
	 * 设置拦截器
	 * @param interceptors 拦截器配置
	 */
	public setInterceptors(interceptors : HttpInterceptors) : void {
		this.interceptors = interceptors
	}

	/**
	 * 核心请求逻辑
	 */
	private coreRequest<T>(options : HttpRequestOptions) : Promise<T> {
		const config = this.beforeRequest(options)

		return new Promise<T>((resolve, reject) => {
			uni.request({
				url: config.url,
				data: config.data as any,
				header: config.header as any,
				method: config.method ?? 'GET',
				timeout: config.timeout ?? 60000,
				success: (res : any) => {
					this.handleResponse<T>(res, config).then(resolve).catch(reject)
				},
				fail: (err : any) => {
					this.handleError(err, config)
					reject(err)
				},
			})
		})
	}

	/**
	 * 请求前拦截与配置处理
	 */
	private beforeRequest(options : HttpRequestOptions) : HttpRequestOptions {
		const config : HttpRequestOptions = {
			...options,
			url: options.url,
			data: options.data,
			method: options.method,
			header: options.header || this.header,
			timeout: options.timeout || this.timeout,
			showLoading: options.showLoading ?? this.showLoading,
			disableAuth: options.disableAuth ?? this.autoAuth
		}

		// 加载提示
		if (config.showLoading ?? this.showLoading) {
			uni.showLoading({ title: config.loadingText ?? '加载中...', mask: true })
		}

		// 拼接 URL
		if (!config.url.startsWith('http')) {
			config.url = this.baseURL + config.url
		}

		// Token 自动添加
		if (this.autoAuth && !config.disableAuth) {
			const token = uni.getStorageSync('token') as string | null
			if (token != null && token != '') {
				const newHeader = {} as UTSJSONObject
				if (config.header != null) {
					for (const key in config.header) {
						newHeader[key] = config.header[key]
					}
				}
				newHeader['Authorization'] = `Bearer ${token}`
				config.header = newHeader
			}
		}

		// GET 请求防缓存
		if (config.method == 'GET') {
			const newData = {} as UTSJSONObject
			if (config.data != null) {
				for (const key in config.data) {
					newData[key] = config.data[key]
				}
			}
			newData['_t'] = Date.now()
			config.data = newData
		}

		// 自定义拦截器
		if (this.interceptors.request != null) {
			return this.interceptors.request(config)
		}

		return config
	}

	/**
	 * 响应处理逻辑
	 */
	private handleResponse<T>(response : any, options : HttpRequestOptions) : Promise<T> {
		uni.hideLoading()

		const statusCode = response.statusCode
		const data = response.data

		let res : ResponseData<T>
		if (typeof data == 'string') {
			res = JSON.parse(data) as ResponseData<T>
		} else {
			res = data as ResponseData<T>
		}

		// 自定义响应拦截器（优先）
		if (this.interceptors.response != null) {
			const intercepted = this.interceptors.response(res, options)
			if (intercepted !== undefined) {
				return Promise.resolve(intercepted as T)
			}
		}

		// HTTP 层错误
		if (statusCode < 200 || statusCode >= 300) {
			const msg = this.getHttpErrorMsg(statusCode)
			uni.showToast({ title: msg, icon: 'none' })
			return Promise.reject(new Error(msg))
		}

		// 业务逻辑错误
		if (res.code != 200 && res.code != 0) {
			if (res.code == 401) {
				uni.showToast({ title: '登录已过期，请重新登录', icon: 'none' })
			} else {
				uni.showToast({ title: res.msg ?? '请求失败', icon: 'none' })
			}
			return Promise.reject(res)
		}

		return Promise.resolve(res as T)
	}

	/**
	 * 错误统一处理
	 */
	private handleError(error : any, options : HttpRequestOptions) : void {
		uni.hideLoading()
		if (this.interceptors.error != null) {
			this.interceptors.error(error, options)
		}
		uni.showToast({ title: '网络异常，请稍后重试', icon: 'none' })
	}

	/**
	 * HTTP 状态码消息
	 */
	private getHttpErrorMsg(status : number) : string {
		const messages : Record<number, string> = {
			400: '请求参数错误',
			401: '未授权，请登录',
			403: '拒绝访问',
			404: '请求的资源不存在',
			405: '请求方法不允许',
			408: '请求超时',
			500: '服务器错误',
			502: '网关错误',
			503: '服务不可用',
			504: '网关超时'
		}
		return messages[status] ?? '请求失败'
	}

	/**
	 * GET 请求
	 * @param url 请求地址
	 * @param data 请求参数
	 * @param options 额外配置
	 */
	public get<T>(url : string, data ?: UTSJSONObject | null, options ?: HttpRequestOptions | null) : Promise<T> {
		const config : HttpRequestOptions = {
			url: url,
			data: data,
			method: 'GET',
			...options
		}
		return this.coreRequest<T>(config)
	}

	/**
	 * POST 请求
	 * @param url 请求地址
	 * @param data 请求数据
	 * @param options 额外配置
	 */
	public post<T>(url : string, data ?: UTSJSONObject | null, options ?: HttpRequestOptions | null) : Promise<T> {
		const config : HttpRequestOptions = {
			url: url,
			data: data,
			method: 'POST',
			...options
		}
		return this.coreRequest<T>(config)
	}

	/**
	 * PUT 请求
	 * @param url 请求地址
	 * @param data 请求数据
	 * @param options 额外配置
	 */
	public put<T>(url : string, data ?: UTSJSONObject | null, options ?: HttpRequestOptions | null) : Promise<T> {
		const config : HttpRequestOptions = {
			url: url,
			data: data,
			method: 'PUT',
			...options
		}
		return this.coreRequest<T>(config)
	}

	/**
	 * DELETE 请求
	 * @param url 请求地址
	 * @param data 请求数据
	 * @param options 额外配置
	 */
	public delete<T>(url : string, data ?: UTSJSONObject | null, options ?: HttpRequestOptions | null) : Promise<T> {
		const config : HttpRequestOptions = {
			url: url,
			data: data,
			method: 'DELETE',
			...options
		}
		return this.coreRequest<T>(config)
	}

	/**
	 * 文件上传
	 * @param url 上传地址
	 * @param data 表单数据，需包含 File 字段（文件路径）
	 * @param options 额外配置
	 */
	public upload<T>(
		url : string,
		data ?: UTSJSONObject | null,
		options ?: HttpRequestOptions | null
	) : Promise<T> {
		const config : HttpRequestOptions = {
			url: url,
			data: data,
			...options,
		}

		const uploadConfig = this.beforeRequest(config)

		const { File, ...formData } = uploadConfig.data || {}

		// 如果没有 File，降级为 postFormData
		if (!File) {
			return this.postFormData<T>(url, data, options)
		}

		return new Promise<T>((resolve, reject) => {
			uni.uploadFile({
				url: uploadConfig.url,
				filePath: File,
				name: 'file',
				formData: formData,
				...options,
				success: (res) => {
					this.handleResponse<T>(res, config)
						.then(resolve)
						.catch(reject)
				},
				fail: (err) => {
					this.handleError(err, config)
					reject(err)
				},
			})
		})
	}

	/**
	 * FormData 提交（无文件）
	 * @param url 请求地址
	 * @param data 表单数据
	 * @param options 额外配置
	 */
	public postFormData<T>(
		url : string,
		data ?: UTSJSONObject | null,
		options ?: HttpRequestOptions | null
	) : Promise<T> {
		const config : HttpRequestOptions = {
			url: url,
			data: data,
			method: 'POST',
			header: {
				'Content-Type': 'application/x-www-form-urlencoded'
			},
			...options
		}
		return this.coreRequest<T>(config)
	}
}

export {HttpRequest}
